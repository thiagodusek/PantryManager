package com.pantrymanager.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.pantrymanager.domain.entity.MeasurementUnit as UnitEntity
import com.pantrymanager.domain.usecase.unit.AddUnitUseCase
import com.pantrymanager.domain.usecase.unit.GetAllUnitsUseCase
import com.pantrymanager.domain.usecase.unit.UpdateUnitUseCase
import com.pantrymanager.domain.usecase.unit.DeleteUnitUseCase
import com.pantrymanager.domain.usecase.unit.GetUnitByIdUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

data class UnitState(
    val name: String = "",
    val abbreviation: String = "",
    val multiplyQuantityByPrice: Boolean = false,
    val units: List<UnitEntity> = emptyList(),
    val isLoading: Boolean = false,
    val errorMessage: String? = null,
    val isSuccess: Boolean = false,
    val validationErrors: UnitValidationErrors = UnitValidationErrors(),
    val editingUnit: UnitEntity? = null,
    val showEditDialog: Boolean = false,
    val showDeleteDialog: Boolean = false,
    val unitToDelete: UnitEntity? = null
)

data class UnitValidationErrors(
    val nameError: String? = null,
    val abbreviationError: String? = null
)

@HiltViewModel
class UnitViewModel @Inject constructor(
    private val addUnitUseCase: AddUnitUseCase,
    private val getAllUnitsUseCase: GetAllUnitsUseCase,
    private val updateUnitUseCase: UpdateUnitUseCase,
    private val deleteUnitUseCase: DeleteUnitUseCase,
    private val getUnitByIdUseCase: GetUnitByIdUseCase
) : ViewModel() {

    private val _state = MutableStateFlow(UnitState())
    val state: StateFlow<UnitState> = _state.asStateFlow()

    init {
        loadUnits()
    }

    fun onNameChanged(name: String) {
        _state.value = _state.value.copy(
            name = name,
            validationErrors = _state.value.validationErrors.copy(nameError = null)
        )
    }

    fun onAbbreviationChanged(abbreviation: String) {
        _state.value = _state.value.copy(
            abbreviation = abbreviation,
            validationErrors = _state.value.validationErrors.copy(abbreviationError = null)
        )
    }

    fun onMultiplyQuantityByPriceChanged(multiplyQuantityByPrice: Boolean) {
        _state.value = _state.value.copy(multiplyQuantityByPrice = multiplyQuantityByPrice)
    }

    fun addUnit() {
        if (!validateUnit()) return

        viewModelScope.launch {
            _state.value = _state.value.copy(isLoading = true, errorMessage = null)
            
            try {
                /*
                // Código de conexão com banco comentado
                val unit = Unit(
                    id = 0, // Will be auto-generated by Room
                    name = _state.value.name.trim(),
                    abbreviation = _state.value.abbreviation.trim(),
                    multiplyQuantityByPrice = _state.value.multiplyQuantityByPrice
                )
                
                addUnitUseCase(unit)
                loadUnits() // Reload the list
                */
                
                // Simulação de delay para mostrar loading
                kotlinx.coroutines.delay(1000)
                
                _state.value = _state.value.copy(
                    isLoading = false,
                    isSuccess = true,
                    errorMessage = "Unidade cadastrada com sucesso!"
                )
                clearForm()
            } catch (e: Exception) {
                _state.value = _state.value.copy(
                    isLoading = false,
                    errorMessage = e.message ?: "Erro desconhecido"
                )
            }
        }
    }

    fun startEditUnit(unit: UnitEntity): Unit {
        _state.value = _state.value.copy(
            editingUnit = unit,
            name = unit.name,
            abbreviation = unit.abbreviation,
            multiplyQuantityByPrice = unit.multiplyQuantityByPrice,
            showEditDialog = true,
            validationErrors = UnitValidationErrors()
        )
    }

    fun updateUnit() {
        val editingUnit = _state.value.editingUnit ?: return
        if (!validateUnit(editingUnit.id)) return

        viewModelScope.launch {
            _state.value = _state.value.copy(isLoading = true, errorMessage = null)
            
            try {
                /*
                // Código de conexão com banco comentado
                val updatedUnit = editingUnit.copy(
                    name = _state.value.name.trim(),
                    abbreviation = _state.value.abbreviation.trim(),
                    multiplyQuantityByPrice = _state.value.multiplyQuantityByPrice
                )
                
                updateUnitUseCase(updatedUnit)
                loadUnits()
                */
                
                // Simulação de delay para mostrar loading
                kotlinx.coroutines.delay(1000)
                
                _state.value = _state.value.copy(
                    isLoading = false,
                    isSuccess = true,
                    showEditDialog = false,
                    editingUnit = null,
                    errorMessage = "Unidade atualizada com sucesso!"
                )
                clearForm()
            } catch (e: Exception) {
                _state.value = _state.value.copy(
                    isLoading = false,
                    errorMessage = e.message ?: "Erro desconhecido"
                )
            }
        }
    }

    fun confirmDeleteUnit(unit: UnitEntity): Unit {
        _state.value = _state.value.copy(
            unitToDelete = unit,
            showDeleteDialog = true
        )
    }

    fun deleteUnit() {
        val unitToDelete = _state.value.unitToDelete ?: return

        viewModelScope.launch {
            _state.value = _state.value.copy(isLoading = true, errorMessage = null)
            
            try {
                /*
                // Código de conexão com banco comentado
                deleteUnitUseCase(unitToDelete)
                loadUnits()
                */
                
                // Simulação de delay para mostrar loading
                kotlinx.coroutines.delay(1000)
                
                _state.value = _state.value.copy(
                    isLoading = false,
                    isSuccess = true,
                    showDeleteDialog = false,
                    unitToDelete = null,
                    errorMessage = "Unidade excluída com sucesso!"
                )
                loadUnits()
            } catch (e: Exception) {
                _state.value = _state.value.copy(
                    isLoading = false,
                    errorMessage = e.message ?: "Erro desconhecido"
                )
            }
        }
    }

    fun cancelEdit() {
        _state.value = _state.value.copy(
            showEditDialog = false,
            editingUnit = null
        )
        clearForm()
    }

    fun cancelDelete() {
        _state.value = _state.value.copy(
            showDeleteDialog = false,
            unitToDelete = null
        )
    }

    private fun clearForm() {
        _state.value = _state.value.copy(
            isLoading = false,
            isSuccess = true,
            name = "",
            abbreviation = "",
            multiplyQuantityByPrice = false,
            errorMessage = null,
            validationErrors = UnitValidationErrors()
        )
    }

    fun clearSuccess() {
        _state.value = _state.value.copy(isSuccess = false)
    }

    fun clearError() {
        _state.value = _state.value.copy(errorMessage = null)
    }

    private fun validateUnit(excludeId: Long = -1): Boolean {
        var hasErrors = false
        var nameError: String? = null
        var abbreviationError: String? = null

        val trimmedName = _state.value.name.trim()
        val trimmedAbbreviation = _state.value.abbreviation.trim()

        if (trimmedName.isBlank()) {
            nameError = "Nome da unidade é obrigatório"
            hasErrors = true
        } else {
            // Check if unit name already exists (excluding current unit when editing)
            val nameExists = _state.value.units.any { 
                it.name.equals(trimmedName, ignoreCase = true) && it.id != excludeId
            }
            if (nameExists) {
                nameError = "Esta unidade já existe"
                hasErrors = true
            }
        }

        if (trimmedAbbreviation.isBlank()) {
            abbreviationError = "Abreviação é obrigatória"
            hasErrors = true
        } else {
            // Check if abbreviation already exists (excluding current unit when editing)
            val abbreviationExists = _state.value.units.any { 
                it.abbreviation.equals(trimmedAbbreviation, ignoreCase = true) && it.id != excludeId
            }
            if (abbreviationExists) {
                abbreviationError = "Esta abreviação já existe"
                hasErrors = true
            }
        }

        val errors = UnitValidationErrors(
            nameError = nameError,
            abbreviationError = abbreviationError
        )
        
        _state.value = _state.value.copy(validationErrors = errors)
        return !hasErrors
    }

    private fun loadUnits() {
        /*
        // Código de conexão com banco comentado
        viewModelScope.launch {
            try {
                val units = getAllUnitsUseCase()
                _state.value = _state.value.copy(units = units)
            } catch (e: Exception) {
                _state.value = _state.value.copy(
                    errorMessage = "Erro ao carregar unidades: ${e.message}"
                )
            }
        }
        */
        
        // Simulando lista vazia para demonstração
        _state.value = _state.value.copy(units = emptyList())
    }
}
